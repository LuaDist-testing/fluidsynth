#!/usr/local/bin/lua
---------------------------------------------------------------------
--     This Lua5 script is Copyright (c) 2014, Peter J Billam      --
--                       www.pjb.com.au                            --
--                                                                 --
--  This script is free software; you can redistribute it and/or   --
--         modify it under the same terms as Lua5 itself.          --
---------------------------------------------------------------------
local Version = '1.6'  -- if -s is given, still read the non-'load' config
local VersionDate  = '03sep2014';
local Synopsis = [[
 fluadity &                     # a simple alsa-client , o/p to soundcard
 fluadity -i ProKeys &          # likewise, and connects from the ProKeys
 fluadity -s ./Foo.sf2 -i Pro & # likewise, and loads Foo.sf2 soundfont
 fluadity -d                    # starts a daemon alsa-client Fluadity
 fluadity /tmp/t.mid /tmp/t.wav # converts midi to wav
 fluadity /tmp/t.mid            # like aplaymidi -p TiMidity /tmp/t.mid
 fluadity - /tmp/t.wav          # like timidity -Ow -o /tmp/t.wav -
 fluadity -                     # like timidity -     
 perldoc fluadity               # read the manual :-)
]]

local FS = require 'fluidsynth'
-- require 'DataDumper'

local Curses     = true
local InputPort  = nil
local Soundfonts = {}
local ClientName = 'fluadity'
local ConfigFile = nil   -- use the default unless there's a -f option
local Daemon     = false

local iarg=1; while arg[iarg] ~= nil do
	if not string.find(arg[iarg], '^-[a-z]') then break end
	local first_letter = string.sub(arg[iarg],2,2)
	if first_letter == 'v' then
		local n = string.gsub(arg[0],"^.*/","",1)
		print(n.." version "..Version.."  "..VersionDate)
		os.exit(0)
	elseif first_letter == 'c' then
		Curses = true
	elseif first_letter == 'd' then
		Daemon = true
		if not ConfigFile then ConfigFile = FS.get_sysconf() end
	elseif first_letter == 'f' then
		iarg = iarg+1
		ConfigFile = arg[iarg]
	elseif first_letter == 'i' then
		iarg = iarg+1
		InputPort = arg[iarg]
	elseif first_letter == 'n' then
		iarg = iarg+1
		ClientName = arg[iarg]
	elseif first_letter == 's' then
		iarg = iarg+1
		table.insert(Soundfonts, arg[iarg])
	else
		local n = string.gsub(arg[0],"^.*/","",1)
		print(n.." version "..Version.."  "..VersionDate.."\n\n"..Synopsis)
		os.exit(0)
	end
	iarg = iarg+1
end

local InputFile  = arg[iarg]   -- fluidsynth.lua 1.5 knows '-' means stdin
local OutputFile = arg[iarg+1]

if #Soundfonts > 0 then  -- 1.6
	assert(FS.read_config_file(ConfigFile)) -- throw away config soundfonts
else
	Soundfonts = assert(FS.read_config_file(ConfigFile))
end
-- print(DataDumper(Soundfonts))

--------------- infrastructure from pjblib.lua --------------
local function split(s, pattern, maxNb) -- http://lua-users.org/wiki/SplitJoin
	if not s or string.len(s)<2 then return {s} end
	if not pattern then return {s} end
	if maxNb and maxNb <2 then return {s} end
	local result = { }
	local theStart = 1
	local theSplitStart,theSplitEnd = string.find(s,pattern,theStart)
	local nb = 1
	while theSplitStart do
		table.insert( result, string.sub(s,theStart,theSplitStart-1) )
		theStart = theSplitEnd + 1
		theSplitStart,theSplitEnd = string.find(s,pattern,theStart)
		nb = nb + 1
		if maxNb and nb >= maxNb then break end
	end
	table.insert( result, string.sub(s,theStart,-1) )
	return result
end

----------------- the four major function-groups ----------------

function midi2wav()
	local synth = FS.new_synth( {
		['audio.driver']    = "file",
		['audio.file.type'] = "wav",
		['audio.file.name'] = OutputFile,
		['fast.render']     = true,
	} )
	local sf2ids = assert(FS.sf_load(synth, Soundfonts))
	local player = assert(FS.new_player(synth, InputFile))
	assert(FS.player_play(player))
	assert(FS.player_join(player))
	os.execute('sleep 1')
	assert(FS.player_stop(player))
	FS.delete_synth(synth)
	os.remove(FS.error_file_name())
end

function play_midi()
	local synth = FS.new_synth( {} )
	local sf2ids = assert(FS.sf_load(synth, Soundfonts))
	local player = assert(FS.new_player(synth, InputFile))
	assert(FS.player_play(player))
	assert(FS.player_join(player))
	os.execute('sleep 1')
	assert(FS.player_stop(player))
	FS.delete_synth(synth)
	os.remove(FS.error_file_name())
end

function daemon_client()
	local P    = require 'posix'
	local ALSA = require 'midialsa'
	-- daemonize and detach ; see Camel book 1991 p216
	local child_pid = P.fork()
	if child_pid == 0 then       -- now this is the child
		local daemon_pid = P.fork()
		if daemon_pid == 0 then  -- now this is the child's child
			while true do        -- wait until we're owned by process 1
				if P.getpid('ppid') == 1 then break end
				P.nanosleep(0, 500000)   -- 0.5ms
			end
			function cleanup()
				local tmpfile = FS.error_file_name()
				if tmpfile then os.remove(tmpfile) end   -- 1.5
				os.exit(0)
			end
			P.signal(P.SIGTERM, cleanup)
			P.signal(P.SIGQUIT, cleanup)
			P.signal(P.SIGINT,  cleanup)
			ALSA.client( 'Fluadity', 1, 0, false )
			local settings = {
				-- ['synth.chorus.active'] = false,
				-- ['synth.reverb.active'] = false,
				-- 'audio.periods'=number of audio-buffers used by the driver
				-- 'audio.periods' times 'audio.period-size'=buffer-size
				--  determines the maximum latency of the audio driver.
				['audio.periods']       = 2,   -- min, for low latency
				['audio.period-size']   = 64,  -- min, for low latency
				['audio.realtime-prio'] = 90,  -- big, lor low latency
			}
			local synth = nil
			while true do  -- loop until killed
				local alsaevent = ALSA.input()
				if alsaevent[1] == ALSA.SND_SEQ_EVENT_PORT_UNSUBSCRIBED then
					-- 1.4 running an inactive synth burns 7% CPU
					--     with chorus and reverb off it still burns 4.5%
					local from = ALSA.listconnectedfrom()  -- 1.4
					if #from == 0 and synth then
						FS.delete_synth(synth)
						synth = nil
					end
				elseif alsaevent[1]==ALSA.SND_SEQ_EVENT_PORT_SUBSCRIBED then
					local from = ALSA.listconnectedfrom()  -- 1.4
					if #from > 0 and not synth then
						synth = FS.new_synth( settings )
						assert(FS.sf_load(synth, Soundfonts))
					end
				elseif synth then
					FS.play_event(synth, alsaevent)
				end
			end
			-- never gets here :-)
		end
		os.exit(0)  -- the daemon is now detached
	end
	P.wait(child_pid)
	return
end

function quiet_client()
	local ALSA = require 'midialsa'
	ALSA.client( ClientName, 1, 0, false )
	for i,val in ipairs(split(InputPort,',')) do ALSA.connectfrom(0,val) end
	local synth = FS.new_synth( {
		['audio.periods']       = 2,   -- min, for low latency
		['audio.period-size']   = 64,  -- min, for low latency
		['audio.realtime-prio'] = 85,  -- big, lor low latency
	} )
	local sf2ids = assert(FS.sf_load(synth, Soundfonts))
	while true do
		local alsaevent = ALSA.input()
		if alsaevent[1] == ALSA.SND_SEQ_EVENT_PORT_UNSUBSCRIBED then
			local from = ALSA.listconnectedfrom()
			if #from == 0 then break end
		end
		FS.play_event(synth, alsaevent)   --print(DataDumper(alsaevent))
	end
	FS.delete_synth(synth)
	os.remove(FS.error_file_name())
end

----------------------------------------------------------------

if InputFile and OutputFile then midi2wav() -- midi to wav
elseif InputFile then play_midi()           -- play midi
elseif Daemon    then daemon_client()
else                  quiet_client()        -- alsa-client
end
os.exit(0)

--[=[

=pod

=head1 NAME

B<fluadity> - Synthesiser and midi-to-wav converter using the Fluidsynth library

=head1 SYNOPSIS

 fluadity &               # a non-verbose alsa-client, o/p to soundcard
 fluadity -i ProKeys &        # likewise, and connects from the ProKeys
 fluadity -s ./Foo.sf2 -i Pro & # likewise, and loads Foo.sf2 soundfont
 fluadity /tmp/t.mid /tmp/t.wav # converts midi to wav
 fluadity /tmp/t.mid            # like aplaymidi -p TiMidity /tmp/t.mid
 fluadity - /tmp/t.wav          # like timidity -Ow -o /tmp/t.wav -
 fluadity -                     # like timidity -     
 perldoc fluadity               # read the manual :-)

 ~> cat ~/.config/fluidsynth
 audio.driver = alsa
 synth.polyphony = 1024
 load /home/soundfonts/MyGM.sf2
 load /home/soundfonts/ReallyGoodPiano.sf2
 ~>

=head1 DESCRIPTION

The name I<fluidity> would be a great variant on I<timidity>
(which in turn is a magnificent variant of I<audacity>),
but 'fluidity' is already a one-person Nintendo video game, released 6dec2010.

  http://en.wikipedia.org/wiki/Fluidity_%28video_game%29
  http://www.nintendo.com/gamesites/wii/fluidity/

So the name I<fluadity> was chosen,
since it also contains I<Lua> which is the language it uses,
and has no previous meaning, is easy to pronounce, and is highly searchable.

It is intended to have a much lower latency than I<timidity>,
so as to be good for real-time work.
Its command-line is leaner and easier to remember than
I<timidity>'s (which is however already pretty good).
But: it can only use SoundFonts, and so is less configurable than I<timidity>.

It has very similar functionality to the I<fluidsynth> command,
but is even easier to use, slightly more restricted in functionality,
and features a convenient default configuration file I<~/.config/fluidsynth>

It uses the I<midialsa> and I<fluidity> Lua modules,
which in turn need the I<alsa> and I<fluidsynth> C-libraries
and associated header-files.
Because it uses the I<midialsa> library, it feels most at home on I<Linux>

I<fluadity> terminates when all its inputs disconnect.

Of course it also terminates if killed or interrupted (eg: with ctrl-C twice),
but in this case it leaves a temporary file undeleted in I</tmp>
containing all the library's I<stderr> output.

=head1 OPTIONS

=over 3

=item I<-f /wherever/my_fluidsynth_config>

Reads the configuration from the given file.
The default configuration file is

 $HOME/.config/fluidsynth

which is in a format that can also be used as a config
file for the I<fluidsynth> executable, eg:

 fluidsynth -f ~/.config/fluidsynth

but I<fluadity> only recognises two types of command,
the first of which is ignored by I<fluidsynth>.
This is the format:

 audio.driver = alsa
 load /home/soundfonts/MyGM.sf2
 load /home/soundfonts/ReallyGoodPiano.sf2

=item I<-i ProKeys,Keystation>

Starts an I<ALSA>-midi client, which it connects from
(in this example) the I<ProKeys> and I<Keystation> midi-keyboards.

=item I<-s /home/soundfonts/Wierd.sf2 -s Gulp.sf2>

Overriding any config file, this loads the soundfonts from the command-line.
Multiple B<-s> options may be given.

=item I<-v>

Prints the Version

=back

=head1 DOWNLOAD

I<Fluadity> is available at:

 http://www.pjb.com.au/midi/free/fluadity

Just move it into your I<PATH>, make it executable,
and if necessary edit the first line to match where I<Lua> is
installed on your system.

You will also need the I<fluidsynth> and I<midialsa> modules:

 luarocks install --server=http://rocks.moonscript.org fluidsynth
 luarocks install --server=http://rocks.moonscript.org midialsa

See:

 http://www.pjb.com.au/comp/lua/fluidsynth.html#download
 http://www.pjb.com.au/comp/lua/midialsa.html#download

=head1 AUTHOR

Peter J Billam, http://www.pjb.com.au/comp/contact.html

=head1 SEE ALSO

 http://www.pjb.com.au/
 http://www.pjb.com.au/midi/index.html
 http://www.pjb.com.au/midi/fluadity.html
 http://www.pjb.com.au/comp/lua/fluidsynth.html
 http://www.pjb.com.au/comp/lua/midialsa.html
 http://rocks.moonscript.org/modules/peterbillam

=cut

]=]
