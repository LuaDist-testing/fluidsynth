<HTML><HEAD><TITLE>fluidsynth.lua</TITLE>
<LINK rel=stylesheet type="text/css"
href="../styles.css" title="PJB Computing Styles">
<META HTTP-EQUIV="Keywords"
CONTENT="MIDI, ALSA, Lua, module, luarock, fluidsynth">
</HEAD>
<BODY LINK="#000066" VLINK="#000066" ALINK="#000066">
<DIV>
<H1><IMG SRC="../logo.jpg" ALT=" " WIDTH=126 HEIGHT=52>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<FONT COLOR="#800000"><I>fluidsynth.lua</I></FONT>
</H1>

<!-- INDEX BEGIN -->

<TABLE ALIGN="center" WIDTH="85%" BORDER=0 CELLSPACING=0>
<TR><TD ALIGN="left">

<ul>
	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
</ul>
</TD><TD ALIGN="left">
<ul>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#functions">FUNCTIONS</a></li>
</ul>
</TD><TD ALIGN="left">
<ul>
	<li><a href="#download">DOWNLOAD</a></li>
	<li><a href="#changes">CHANGES</a></li>
</ul>
</TD><TD ALIGN="left">
<ul>
	<li><a href="#author">AUTHOR</a></li>
	<li><a href="#see_also">SEE ALSO</a></li>
</ul>
</TD></TR>
</TABLE>

<hr />
<p></p>
<!-- INDEX END -->

<h2><a name="name">NAME</a></h2>
<p><B>fluidsynth</B> &nbsp; - &nbsp;
a Lua interface to the <I>fluidsynth</I> library</p>
<p>
</p>
<hr />
<h2><a name="synopsis">SYNOPSIS</a></h2>
<pre>
 local FS = require 'fluidsynth'   -- convert midi to wav
 local synth1   = <A HREF="#new_synth">FS.new_synth(
   ['synth.gain']      = 0.4,      -- be careful...
   ['audio.driver']    = 'file',
   ['audio.file.name'] = 'foo.wav',
   ['fast.render']     = true,     -- a homebrew parameter
 } )</A>
 local my_gm,msg = <A HREF="#sf_load">FS.sf_load(synth1, &quot;/home/soundfonts/MyGM.sf2&quot;)</A>
 local player1  = <A HREF="#new_player">FS.new_player(synth1,'foo.mid')</A>
 -- the 2nd arg automatically invokes player_add(synth1,'foo.mid')
 assert(<A HREF="#player_play">FS.player_play(player1)</A>)
 assert(<A HREF="player_join">FS.player_join(player1)</A>)   -- wait for foo.mid to finish
 os.execute('sleep 1')             -- don't chop final reverb
 <A HREF="#delete_synth">FS.delete_synth(synth1)</A> -- deletes player,audio_driver,synth,settings</pre>
<pre>
 local FS   = require 'fluidsynth' -- an alsa-client soundfont-synth
 local ALSA = <A HREF="midialsa.html">require 'midialsa'</A>
 local Input      = 14
 local Soundfonts = { '/home/soundfonts/MyGM.sf2', }
 ALSA.client( 'fluidsynth-alsa-client', 1, 0, false )
 ALSA.connectfrom( 0, Input )
 local synth2 = <A HREF="#new_synth">FS.new_synth( {
   &quot;audio.driver&quot;      = &quot;alsa&quot;,
   &quot;audio.periods&quot;     = 2,   -- min, for low latency
   &quot;audio.period-size&quot; = 64,  -- min, for low latency
 } )</A>
 local sf_id = <A HREF="#sf_load">FS.sf_load(synth2, Soundfonts)</A>
 -- you will need to set a patch before any output can be generated!
 while true do
   local alsaevent = ALSA.input()
   if alsaevent[1]==ALSA.SND_SEQ_EVENT_PORT_UNSUBSCRIBED then break end
   <A HREF="#play_event">FS.play_event(synth2, alsaevent)</A>
 end
 <A HREF="#delete_synth">FS.delete_synth(synth2)</A></pre>
<p>
</p>
<hr />
<h2><a name="description">DESCRIPTION</a></h2><p>
This Lua module offers a simplified calling interface
to the Fluidsynth Library.
</p><p>
It is in its early versions, and the API is expected to change and evolve.
</p><p>
It is a relatively thick wrapper.  Various higher-level
<A HREF="#functions">functions</A>
are introduced,
the library's voluminous output on <I>stderr</I> has been redirected
so the module can be used for example within a <I>Curses</I> app,
and the return codes on failure have adopted the <I>nil,errormessage</I>
convention of Lua so they can be used for example with <I>assert()</I>.
</p><p>
</p>
<hr />
<h2><a name="functions">FUNCTIONS</a></h2>
<p>These higer-level functions wrap the <I>fluidsynth</I> library
functions in a way that retains functionality,
but is easy to use and hides some of the dangerous internals.
Unless otherwise stated,
these functions all return <I>nil,errormessage</I> on failure.
</p><p>
Included are basic functions:<B>
<A HREF="#read_config_file">read_config_file</A>,
<A HREF="#new_synth">new_synth</A>,
<A HREF="#sf_load">sf_load</A>,
<A HREF="#delete_synth">delete_synth</A>,
</B><BR>functions for playing midi files:<B>
<A HREF="#new_player">new_player</A>,
<A HREF="#player_play">player_play</A>,
<A HREF="#player_join">player_join</A>,
<A HREF="#player_stop">player_stop</A>,
</B><BR>functions for playing in real-time:<B>
<A HREF="#note_on">note_on</A>,
<A HREF="#note_off">note_off</A>,
<A HREF="#patch_change">patch_change</A>,
<A HREF="#control_change">control_change</A>,
<A HREF="#pitch_bend">pitch_bend</A>,
<A HREF="#play_event">play_event</A>,
</B><BR>functions returning state:<B>
<A HREF="#is_soundfont">is_soundfont</A>,
<A HREF="#is_midifile">is_midifile</A>,
<A HREF="#default_settings">default_settings</A>,
<A HREF="#all_synth_errors">all_synth_errors</A>
</B></p>
<dl>
<dt><B><I><a name="read_config_file">soundfonts =
FS.read_config_file(filename)</a></I></B></dt>
<dd><P>
If <I>filname</I> is <I>nil</I>,
the default configuration file is <I>$HOME/.fluidsynth</I>,
and if that does not exist then <I>/etc/fluidsynth.conf</I>.
</p><p>
This file can also be used as a configuration file for the
<I>fluidsynth</I> executable (except that <I>fluidsynth</I>
is not able to use the <I>set</I> commands); for example:
</P><PRE>
 fluidsynth -f ~/.fluidsynth
</PRE><P>
This module only recognises two types of command;
this is the format:
</P><PRE>
 set audio.driver alsa
 set synth.polyphony 1024
 load /home/soundfonts/MyGM.sf2
 load /home/soundfonts/ReallyGoodPiano.sf2
</PRE><P>
Invoking the function
<I>soundfonts = FS.read_config_file()</I>
(before creating the first <I>synth</I>!)
changes the default settings for <I>audio.driver</I> and <I>synth.polyphony</I>,
and returns an array of Soundfonts
ready for later use by <A HREF="#sf_load">sf_load(synth,soundfonts)</A>
</P></dd>

<dt><B><I><a name="new_synth">synth =
FS.new_synth({['synth.gain']=0.3, ['audio.driver']='alsa',})
</a></I></B></dt>
<dd><p>
When called with no argument, or with a table argument,
<I>new_synth</I>
wraps the library routines
<I>new_fluid_synth()</I>,
invoking
<I>new_fluid_settings</I>,
<I>fluid_settings_setstr()</I>,
<I>fluid_settings_setnum()</I>,
<I>fluid_settings_setint()</I>, and
<I>new_fluid_audio_driver()</I> automatically as needed.
</p><p>
The return value is a C pointer to the <I>synth</I>,
so don't change that otherwise the library will crash.
</p><p>
Multiple synths may be started.
</p><p>
The meanings and permitted values of the various parameters are documented in
<a href="http://fluidsynth.sourceforge.net/api/">http://fluidsynth.sourceforge.net/api/</a>
with just two additions:</p>
<p><B>1)</B> If the <I>audio.driver</I> parameter is set to &quot;none&quot;
then FS.new_synth() will not automatically create an <I>audio_driver</I>.
You will not need this until support for <I>midi_router</I> is introduced.</p>
<p><B>2)</B> The <I>fast.render</I> parameter is introduced.
You should set it to <I>true</I> if and only if
you are converting MIDI to WAV and no real-time events are involved.
If <I>fast.render</I> is <I>true</I> the conversion will be done at full CPU speed
and will finish an order of magnitude quicker than real time.
Look for <I>fast_render</I> in <I>src/fluidsynth.c</I> for example code.
</P></dd>

<dt><B><I><a name="sf_load">array_of_sf_ids =
FS.sf_load(synth, {'my_gm.sf2', 'my_piano.sf2',})</a></I></B></dt>
<dd><p>
This wraps the library routine <I>fluid_synth_sfload()</I>,
calling it once for each soundfont.
Often, a <I>synth</I> has more than one soundfont;
they go onto a sort of stack, and for a given patch,
<I>fluidsynth</I> will use that soundfont closest to the top of the
stack which can supply the requested patch.
In the above example, <I>my_gm.sf2</I> is a good general-midi soundfont,
except that <I>my_piano.sf2</I> offers a much nicer piano sound.
</p><p>
It returns an array of soundfont_ids, which are stack indexes
starting from 1.<BR>
These soundfont_ids are only needed if you want to invoke
<I>fluid_synth_sfunload()</I> or <I>fluid_synth_sfreload()</I>,
so in most cases you can ignore the return value.
</p></dd>

<dt><B><I><a name="delete_synth">FS.delete_synth(synth)</a></I></B></dt>
<dd><p>
This does all the administrivia necessary to delete the <I>synth</I>,
invoking <I>delete_player</I>, <I>delete_audio_driver</I>,
<I>delete_synth</I> and <I>delete_settings</I> as necessary.</p>
<p>When called with no argument it deletes all running <I>synths</I>.
</p></dd>

<dt><B><I><a name="new_player">player =
FS.new_player(synth, '/tmp/filename.mid')</a></I></B></dt>
<dd><p>
This wraps the library routines <I>new_fluid_player()</I>
and <I>fluid_player_add()</I>,
thus allowing you to play a midi file.
The return value is a C pointer.</p>
<p>One <I>synth</I> may have multiple <I>midi_players</I> running at the same time
(eg: to play several midi files, each starting at a different moment).
Therefore, you still need to call <I>player_play(player)</I>,
<I>player_join(player)</I> and <I>player_stop(player)</I> by hand.
</p></dd>

<dt><B><I><a name="player_play">FS.player_play(midiplayer)</a></I></B></dt>
<dd><p>
This corresponds to the library routine <I>fluid_player_play()</I>
</p></dd>

<dt><B><I><a name="player_join">FS.player_join(midiplayer)</a></I></B></dt>
<dd><p>
This corresponds to the library routine <I>fluid_player_join()</I>
</p></dd>

<dt><B><I><a name="player_stop">FS.player_stop(midiplayer)</a></I></B></dt>
<dd><p>
This corresponds to the library routine <I>fluid_player_stop()</I>
</p></dd>



<dt><B><I><a name="note_on">
FS.note_on(synth, channel, note, velocity)</a></I></B></dt>
<dd><p>
This corresponds to the library routine <I>fluid_synth_noteon()</I>
</p></dd>

<dt><B><I><a name="note_off">
FS.note_off(synth, channel, note, velocity)</a></I></B></dt>
<dd><p>
This corresponds to the library routine <I>fluid_synth_noteoff()</I>
</p></dd>

<dt><B><I><a name="patch_change">
FS.patch_change(synth, channel, patch)</a></I></B></dt>
<dd><p>
This corresponds to the library routine <I>fluid_synth_program_change()</I>
</p></dd>

<dt><B><I><a name="control_change">
FS.control_change(synth, channel, controller, value)</a></I></B></dt>
<dd><p>
This corresponds to the library routine <I>fluid_synth_cc()</I>
</p></dd>

<dt><B><I><a name="pitch_bend">
FS.pitch_bend(synth, channel, val)</a></I></B></dt>
<dd><p>
This corresponds to the library routine <I>fluid_synth_pitch_bend()</I>.
The value should lie between 0 and 16383,
where 8192 represents the default, central, pitch-wheel position.</p>
</p></dd>

<dt><B><I><a name="play_event">FS.play_event(synth, event)</a></I></B></dt>
<dd><p>
This is a wrapper for the above <I>note_on</I>, <I>note_off</I>,
<I>patch_change</I>, <I>control_change</I> and <I>pitch_bend routines</I>,
which accepts events of two different types used in the author's other
midi-related modules:</p>
<p>1) MIDI 'opus' events, see: <a href="http://www.pjb.com.au/comp/lua/MIDI.html#events">http://www.pjb.com.au/comp/lua/MIDI.html#events</a></p>
<p>2) midialsa events, see: <a href="http://www.pjb.com.au/comp/lua/midialsa.html">http://www.pjb.com.au/comp/lua/midialsa.html</a>
</p><p>It will currently only handle real-time events,
so every event received will be played immediately.
It will currently not handle 'note' events (of either type).
</p></dd>

<dt><B><I><a name="is_soundfont">local ok =
FS.is_soundfont(filename)</a></I></B></dt>
<dd><p>
This corresponds to the library routine <I>fluid_is_soundfont()</I>
which checks for the &quot;RIFF&quot; header in the file.
It is useful only to distinguish between SoundFont and MIDI files.  
It returns only <I>true</I> or <I>false</I>.</p>
</p></dd>

<dt><B><I><a name="is_midifile">local ok =
FS.is_midifile(filename)</a></I></B></dt>
<dd><p>
This corresponds to the library routine <I>fluid_is_midifile()</I>
The current implementation only checks for the "MThd" header in the file.
It is useful only to distinguish between SoundFont and MIDI files. 
It returns only <I>true</I> or <I>false</I>.
</p></dd>

<dt><B><I><a name="default_settings">parameter2default =
FS.default_settings()</a></I></B></dt>
<dd><p>
Returns a table of all the supported parameters, with their default values.
This could be useful, for example, in an application,
to offer the user a menu of available parameters.
</p><p>
The meanings and permitted values of the various parameters are documented in
<a href="http://fluidsynth.sourceforge.net/api/">fluidsynth.sourceforge.net/api/</a>
</p></dd>

<dt><B><I><a name="all_synth_errors"> err_string =
FS.all_synth_errors()</a></I></B></dt>
<dd><p>
Returns a multi-line string containing all the C-library's
<I>stderr</I> output.

</p></dd></dl>

<hr />
<!--
<h2><a name="low_level_functions_you_no_longer_need">LOW-LEVEL FUNCTIONS YOU NO LONGER NEED</a></h2>
<p>
</p>
<h3><a name="settings___fs_new_settings__">settings = FS.new_settings()</a></h3>
<p>This corresponds to the library routine <I>new_fluid_settings()</I>
The return value is a C pointer, so if you mess with it the library will crash.</p>
<p>In  <a href="http://fluidsynth.sourceforge.net/api/">http://fluidsynth.sourceforge.net/api/</a>
it says &quot;The settings parameter is used directly,
and should not be modified or freed independently.&quot;
This means that the synth keeps a reference to the settings object.
The consequence is that after invoking <I>new_synth</I>
you are not allowed to touch the settings object,
except that you're responsible to free it after deleting the synth.</p>
<p>
</p>
<h3><a name="fs_set_settings__audio_driver__alsa_">FS.set(settings, &quot;audio.driver&quot;, &quot;alsa&quot;)</a></h3>
<p>This in itself is a wrapper, invoking the library routines
<I>fluid_settings_setstr()</I>,
<I>fluid_settings_setnum()</I>, and
<I>fluid_settings_setint()</I>.
The module knows which type each parameter should be,
and calls the correct routine automatically.</p>
<p>After invoking <I>new_synth</I>
you should not touch its settings object.</p>
<p>
</p>
<h3><a name="synth___fs_new_synth_settings_">synth = FS.new_synth(settings)</a></h3>
<p>This corresponds to the library routine <I>new_fluid_synth()</I>
The return value is a C pointer, so if you mess with it the library will crash.</p>
<p>
</p>
<h3><a name="audio_driver___fs_new_audio_driver_settings__synth_">audio_driver = FS.new_audio_driver(settings, synth)</a></h3>
<p>This corresponds to the library routine <I>new_fluid_audio_driver()</I>
The return value is a C pointer.</p>
<p>
</p>
<h3><a name="fs_player_add_midiplayer__midifilename_">FS.player_add(midiplayer, midifilename)</a></h3>
<p>This corresponds to the library routine <I>fluid_player_add()</I></p>
<p>
</p>
<h3><a name="fs_delete_settings_settings_">FS.delete_settings(settings)</a></h3>
<p>This corresponds to the library routine <I>delete_fluid_settings()</I></p>
<p>
</p>
<h3><a name="fs_delete_audio_driver_audio_driver_">FS.delete_audio_driver(audio_driver)</a></h3>
<p>This corresponds to the library routine <I>delete_fluid_audio_driver()</I></p>
<p>
</p>
<h3><a name="fs_delete_player_midiplayer_">FS.delete_player(midiplayer)</a></h3>
<p>This corresponds to the library routine <I>delete_fluid_player()</I></p>
<p>

</p><hr />
<h2><a name="download">DOWNLOAD</a></h2>
<p>This module is available as a LuaRock in
<a href="http://rocks.moonscript.org/modules/peterbillam">
rocks.moonscript.org/modules/peterbillam</a>
so you should be able to install it with the command:</p>
<pre>
 $ su
 Password:
 # luarocks install --server=http://rocks.moonscript.org fluidsynth</pre>
<p>or:</p>
<pre>
 # luarocks install http://www.pjb.com.au/comp/lua/fluidsynth-1.3-0.rockspec</pre>
<p>It depends on the <I>fluidsynth</I> library and its header-files;
for example on Debian you may need:
</p><pre>
 # aptitude install libfluidsynth libfluidsynth-dev
</pre><p>
or on Centos you may need:</p><pre>
 # yum install fluidsynth-devel</pre>
<p>
</p>
<hr />
<h2><a name="changes">CHANGES</a></h2>
<pre>
 20140827 1.3 use fluid_get_sysconf, fluid_get_userconf,  set k v
 20140826 1.2 sf_load takes 2nd arg as an array; ~/.config/fluidsynth k = v
 20140825 1.1 new calling-interface at much higher level
 20140818 1.0 first working version</pre>
<p>
</p>
<hr />
<h2><a name="author">AUTHOR</a></h2>
<p>Peter Billam, 
<a href="http://www.pjb.com.au/comp/contact.html">http://www.pjb.com.au/comp/contact.html</a></p>
<p>
</p>
<hr />
<h2><a name="see_also">SEE ALSO</a></h2>
<pre>
 man fluidsynth
 /usr/include/fluidsynth.h
 /usr/include/fluidsynth/*.h
 <a href="http://fluidsynth.sourceforge.net/api/">http://fluidsynth.sourceforge.net/api/</a>
 <a href="http://www.pjb.com.au">http://www.pjb.com.au</a>
 <a href="http://www.pjb.com.au/comp/index.html#lua">http://www.pjb.com.au/comp/index.html#lua</a>
 <a href="http://www.pjb.com.au/comp/lua/fluidsynth.html">http://www.pjb.com.au/comp/lua/fluidsynth.html</a>
 <a href="http://www.pjb.com.au/comp/lua/midialsa.html">http://www.pjb.com.au/comp/lua/midialsa.html</a>
 <a href="http://www.pjb.com.au/comp/lua/MIDI.html">http://www.pjb.com.au/comp/lua/MIDI.html</a>
 <a href="http://www.pjb.com.au/midi/fluadity.html">http://www.pjb.com.au/midi/fluadity.html</a></pre>

</body>

</html>
